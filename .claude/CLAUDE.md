# CorpusAI - Development Rules

## General Philosophy

### Technical Excellence
- Always implement the most optimized and performant solution
- Front-end: minimal bundle size, lazy loading, optimistic UI
- Back-end: optimized queries, appropriate caching, pagination
- AI/RAG: efficient embeddings, optimized vector search
- No technical debt accepted from the start

### Code Quality
- TypeScript strict mode mandatory
- No `any` except documented exceptional cases
- Tests for all critical business logic
- Automatic linting and formatting (ESLint + Prettier)

---

## Conventional Commits

Mandatory format for all commits:

```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

### Allowed Types
| Type | Usage |
|------|-------|
| `feat` | New feature |
| `fix` | Bug fix |
| `docs` | Documentation only |
| `style` | Formatting, no code change |
| `refactor` | Refactoring without adding feature or fix |
| `perf` | Performance improvement |
| `test` | Adding or modifying tests |
| `chore` | Maintenance, dependencies, config |

### Recommended Scopes
- `web`, `api`, `ui`, `types`, `database`, `corpus`, `ai-rules`, `subscription`

### Examples
```
feat(web): add document upload drag-and-drop
fix(api): prevent duplicate embeddings on re-upload
perf(corpus): batch embedding requests for faster indexing
refactor(ui): extract ChatMessage into atomic component
```

### Strict Rules
- **NEVER mention Claude, AI assistant, or similar tools in commits**
- **NEVER use "Generated by..." or equivalent**
- Clear and descriptive messages in English
- Lowercase first letter after type
- No trailing period

---

## Atomic Design (UI)

The `@corpusai/ui` package strictly follows Atomic Design:

### Component Hierarchy

```
src/
├── atoms/          # Indivisible elements
│   ├── Button.tsx
│   ├── Input.tsx
│   ├── Badge.tsx
│   ├── Avatar.tsx
│   ├── Skeleton.tsx
│   └── Icon.tsx
│
├── molecules/      # Atom combinations
│   ├── FormField.tsx      # Label + Input + Error
│   ├── Card.tsx           # Container + Header + Body
│   ├── Toast.tsx          # Icon + Message + Action
│   ├── Tooltip.tsx        # Trigger + Content
│   └── SearchBar.tsx      # Input + Button + Icon
│
├── organisms/      # Complete sections
│   ├── ChatInterface.tsx  # Messages + Input + Actions
│   ├── DocumentUploader.tsx
│   ├── AICard.tsx
│   ├── ConversationList.tsx
│   └── SourceCitation.tsx
│
├── templates/      # Page layouts
│   ├── DashboardLayout.tsx
│   ├── ChatLayout.tsx
│   └── WidgetLayout.tsx
│
└── pages/          # Final assembly (in apps/web)
```

### Atomic Design Rules
1. **Atoms**: No dependency on other UI components
2. **Molecules**: Composed only of atoms
3. **Organisms**: Can use atoms, molecules, and other organisms
4. **Templates**: Structure without real data
5. **Pages**: Connect templates to data

### Naming Conventions
- PascalCase for components
- One file = one default exported component
- Props typed with `interface ComponentNameProps`
- Variants via `cva()` from class-variance-authority

---

## Performance Guidelines

### Front-end
- Images: Next/Image with AVIF/WebP formats
- Fonts: `next/font` with subset
- Bundle: Regularly analyze with `@next/bundle-analyzer`
- Hydration: Minimize client components

### Back-end
- Queries: Always use `select` to limit fields
- N+1: Use Prisma `include` intelligently
- Cache: Redis for frequent data (appropriate TTL)
- Rate limiting: Configure per endpoint

### AI/RAG
- Embeddings: Batch requests (max 100 per call)
- Qdrant: HNSW index for fast search
- Chunks: Optimal size 500-1000 tokens
- LLM: Streaming for reactive UX

---

## Design System

### Color Palette (Dark Theme)
```css
:root {
  /* Dark/neutral base */
  --background: 240 10% 3.9%;        /* #0a0a0f */
  --foreground: 0 0% 98%;
  --card: 240 10% 5.9%;
  --muted: 240 5% 15%;
  --muted-foreground: 240 5% 65%;

  /* Cold primary color (blue-violet) */
  --primary: 221 83% 53%;
  --primary-foreground: 0 0% 100%;

  /* Discrete accent */
  --accent: 240 5% 15%;
  --accent-foreground: 0 0% 98%;

  /* States */
  --destructive: 0 62% 50%;
  --success: 142 76% 36%;
  --warning: 38 92% 50%;
  --border: 240 5% 17%;
  --ring: 221 83% 53%;
}
```

### Typography
- Sans: Inter, system-ui, sans-serif
- Mono: JetBrains Mono, monospace

### Visual Principles
- Dark base for reduced eye strain
- Cold blue accent for primary actions, never aggressive
- Soft contrasts, clear hierarchy
- Inter for text, generous sizes

---

## Agents de développement

Selon le contexte de la tâche, utiliser automatiquement l'agent approprié :

| Agent | Fichier | Contexte d'utilisation |
|-------|---------|------------------------|
| Frontend Engineer | `.claude/agents/frontend-engineer.md` | `apps/web/`, `packages/ui/`, composants React, pages Next.js |
| Backend Engineer | `.claude/agents/backend-engineer.md` | `apps/api/`, `packages/database/`, endpoints, Prisma |
| AI/RAG Engineer | `.claude/agents/ai-rag-engineer.md` | `apps/ai-worker/`, `packages/corpus/`, embeddings, Qdrant |
| Fullstack Lead | `.claude/agents/fullstack-lead.md` | Architecture globale, refactoring cross-packages, code review |

### Règles d'utilisation
1. Identifier le domaine principal de la tâche
2. Lire l'agent correspondant pour appliquer ses standards
3. Si multi-domaines → utiliser Fullstack Lead
4. Toujours respecter les checklists qualité de l'agent
